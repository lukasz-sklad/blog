--- 
title: Jak daÅ‚em mojemu blogowi gÅ‚os? Budujemy wÅ‚asne API AI na Proxmoxie! ğŸ—£ï¸âš¡
description: 'Historia o tym, jak poÅ‚Ä…czyliÅ›my statycznego bloga z domowym serwerem, aby usÅ‚yszeÄ‡ gÅ‚os Gosi zamiast robota. Docker, Python, Piper TTS i Cloudflare Tunnel w akcji.'
summary: 'Docker, Piper TTS, Cloudflare Tunnel, Next.js'
date: GrudzieÅ„ December 19 2025
slug: wlasny-tts-ai-proxmox-piper
---

# Jak daÅ‚em mojemu blogowi gÅ‚os? Budujemy wÅ‚asne API AI na Proxmoxie! ğŸ—£ï¸âš¡

Czy zdarzyÅ‚o Ci siÄ™ kiedyÅ› kliknÄ…Ä‡ "Czytaj na gÅ‚os" w przeglÄ…darce i skrzywiÄ‡ siÄ™, sÅ‚yszÄ…c metaliczny, bezduszny gÅ‚os robota z lat 90.? Mnie teÅ¼. ğŸ¤–

MarzyÅ‚em o czymÅ› lepszym. O blogu, ktÃ³ry **mÃ³wi do czytelnika** naturalnym, pÅ‚ynnym gÅ‚osem. Ale nie chciaÅ‚em pÅ‚aciÄ‡ milionÃ³w za API od gigantÃ³w technologicznych. PrzecieÅ¼ mam w domu serwer (Proxmox), mam Debiana i mam chÄ™ci! ğŸ ğŸ’ª

W tym artykule pokaÅ¼Ä™ Wam, jak zbudowaÅ‚em **wÅ‚asne, prywatne API Text-to-Speech (TTS)**, ktÃ³re dziaÅ‚a na moim domowym sprzÄ™cie i "nadaje" gÅ‚os prosto do Waszych przeglÄ…darek â€“ nawet na Steam Decku! ğŸš€

## Architektura: Plan Bitwy ğŸ—ºï¸

Nasz cel byÅ‚ ambitny: poÅ‚Ä…czyÄ‡ statycznego bloga (Next.js na Netlify) z kontenerem w mojej piwnicy, bez wystawiania routera na Å›wiat.

UÅ¼yliÅ›my do tego:
1.  **Backend:** Domowy Debian na Proxmoxie.
2.  **Silnik:** [Piper TTS](https://github.com/rhasspy/piper) â€“ niesamowicie szybki i lekki model AI (wybraÅ‚em gÅ‚os `pl_PL-gosia-medium`).
3.  **API:** WÅ‚asny mikro-serwer w Pythonie (Flask).
4.  **Transport:** [Cloudflare Tunnel](https://www.cloudflare.com/products/tunnel/) â€“ magiczna rura, ktÃ³ra bezpiecznie wystawia nasz lokalny serwer na Å›wiat (HTTPS) bez przekierowywania portÃ³w! ğŸ›¡ï¸
5.  **Frontend:** Inteligentny komponent w React, ktÃ³ry decyduje, kiedy uÅ¼yÄ‡ AI.

---

## Krok 1: Serwer "Szyty na MiarÄ™" ğŸ§µ

PoczÄ…tkowo prÃ³bowaliÅ›my gotowych rozwiÄ…zaÅ„ (OpenTTS, wyoming), ale ciÄ…gle czegoÅ› brakowaÅ‚o. Biblioteki siÄ™ gryzÅ‚y, Python marudziÅ‚... PostanowiliÅ›my wiÄ™c zbudowaÄ‡ wÅ‚asny kontener od zera na bazie Ubuntu.

Oto serce naszego systemu â€“ skrypt `server.py`, ktÃ³ry przyjmuje tekst i zamienia go na plik WAV przy uÅ¼yciu Pipera:

```python
# server.py - Nasz Wrapper API
from flask import Flask, request, send_file, make_response
import subprocess
import os

app = Flask(__name__)

@app.route('/api/tts', methods=['GET'])
def tts():
    text = request.args.get('text')
    if not text: return 'No text', 400
    
    # Piper wymaga nowej linii na koÅ„cu, Å¼eby wiedzieÄ‡, Å¼e to koniec zdania
    input_text = text + '\n' 
    
    # PeÅ‚ne Å›cieÅ¼ki - klucz do sukcesu w Dockerze!
    cmd = ['/app/piper/piper', '--model', '/app/pl_PL-gosia-medium.onnx', '--output_file', '/app/output.wav']
    
    try:
        # Uruchamiamy proces Pipera i karmimy go tekstem przez stdin
        process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        stdout, stderr = process.communicate(input=input_text.encode('utf-8'))
        
        if process.returncode != 0:
            return f'Piper Error: {stderr.decode("utf-8")}', 500
            
        # Zwracamy plik audio z odpowiednimi nagÅ‚Ã³wkami (CORS!)
        response = make_response(send_file('/app/output.wav', mimetype='audio/wav'))
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Content-Disposition'] = 'inline; filename=tts.wav'
        return response
        
    except Exception as e:
        return str(e), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

Aby to uruchomiÄ‡, potrzebowaliÅ›my solidnego Å›rodowiska. Oto nasz pancerny `Dockerfile`:

```dockerfile
FROM ubuntu:22.04

WORKDIR /app

# Instalujemy zaleÅ¼noÅ›ci systemowe (kluczowe dla Pipera!)
RUN apt-get update && \
    apt-get install -y python3 python3-pip wget tar espeak-ng-data libespeak-ng1 && \
    rm -rf /var/lib/apt/lists/*

RUN pip3 install flask

# Pobieramy binarkÄ™ Pipera
RUN wget -O piper.tar.gz 'https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_linux_x86_64.tar.gz' && \
    tar -xvf piper.tar.gz && \
    rm piper.tar.gz

# Kopiujemy nasz skrypt i model gÅ‚osu (Gosia!)
COPY . .

# Linkujemy pythona
RUN ln -s /usr/bin/python3 /usr/bin/python

CMD ["python3", "server.py"]
```

---

## Krok 2: Wielkie SpiÄ™cie (Docker Compose) ğŸ³

MajÄ…c obraz, musieliÅ›my go poÅ‚Ä…czyÄ‡ ze Å›wiatem. Tu wchodzi **Cloudflare Tunnel**. DziÄ™ki niemu mÃ³j lokalny kontener jest dostÄ™pny pod adresem `https://tts.lmk.one`, a ja mam darmowy certyfikat SSL i Å›piÄ™ spokojnie.

Plik `docker-compose.yml`:

```yaml
version: '3.8'

services:
  my-piper:
    build: ./app
    container_name: my-piper
    restart: unless-stopped
    ports:
      - "5000:5000"
    networks:
      - tts-net

  cloudflared:
    container_name: cloudflared-tunnel
    image: cloudflare/cloudflared:latest
    restart: unless-stopped
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=TU_BYL_MOJ_SEKRETNY_TOKEN
    depends_on:
      - my-piper
    networks:
      - tts-net

networks:
  tts-net:
    driver: bridge
```

WystarczyÅ‚o jedno polecenie, by oÅ¼ywiÄ‡ bestiÄ™:
```bash
docker compose up -d --build
```

---

## Krok 3: Inteligentny Frontend (React) ğŸ§ 

Teraz najciekawsze. Nie chciaÅ‚em, Å¼eby **kaÅ¼dy** uÅ¼ywaÅ‚ mojego domowego serwera. JeÅ›li ktoÅ› ma Chrome na Androidzie, ma tam Å›wietne wbudowane gÅ‚osy Google. Po co marnowaÄ‡ mÃ³j prÄ…d?

StworzyÅ‚em wiÄ™c system hybrydowy w `SpeechControl.js`:

1.  **SprawdÅº przeglÄ…darkÄ™:** Czy masz wbudowane gÅ‚osy (Web Speech API)?
2.  **Tak (np. Chrome):** UÅ¼yj ich! Szybko, lokalnie, za darmo.
3.  **Nie (np. Firefox na Linuxie/Steam Deck):** Aaa, tutaj ciÄ™ mam! ğŸ•µï¸â€â™‚ï¸
4.  **Fallback:** PoÅ‚Ä…cz siÄ™ z moim serwerem `tts.lmk.one`, wyÅ›lij tekst, odbierz gÅ‚os Gosi wygenerowany przez AI i odtwÃ³rz go w przeglÄ…darce.

Dodatkowo zadbaliÅ›my o detale:
*   **SÅ‚ownik wymowy:** "vs" czytamy jako "kontra", "ssh" jako "es es ha".
*   **Czyszczenie:** Wycinamy emoji ğŸš€, bo lektor czytajÄ…cy "rakieta startuje" psuje klimat.
*   **Interpunkcja:** Podmieniamy kropki na spacje, Å¼eby lektor nie mÃ³wiÅ‚ sÅ‚owa "kropka", ale zostawiamy przecinki, Å¼eby robiÅ‚ naturalne pauzy.

```javascript
// Fragment logiki
const toggleRead = () => {
    if (useFallback) {
        // Tryb AI Home (Proxmox)
        playRemoteTTS(text);
    } else {
        // Tryb Natywny (System)
        const ut = new SpeechSynthesisUtterance(text);
        window.speechSynthesis.speak(ut);
    }
};
```

## Efekt KoÅ„cowy âœ¨

Teraz mogÄ™ wejÅ›Ä‡ na bloga z mojego Steam Decka, wcisnÄ…Ä‡ "Czytaj" i usÅ‚yszeÄ‡ pÅ‚ynny, polski gÅ‚os generowany w czasie rzeczywistym na serwerze w drugim pokoju. Zero reklam, zero opÅ‚at, peÅ‚na kontrola.

To byÅ‚ projekt "teoretyczny", ktÃ³ry staÅ‚ siÄ™ praktyczny. I to jest w IT najpiÄ™kniejsze! â¤ï¸

<br/>
<button onClick={() => alert("DziÄ™kujÄ™ za odsÅ‚uchanie historii o Gosi i Piperze! ğŸ§")}>
  Mam nadziejÄ™, Å¼e ten projekt zainspiruje CiÄ™ do wÅ‚asnych eksperymentÃ³w z AI! Do zobaczenia w kolejnym wpisie! ğŸ§™â€â™‚ï¸ğŸŒŸ
</button>
